<!doctype html>
<html lang="en-us">
  <head>
    <title>Perl Weekly Challenge 14: van Eck’s sequence / Adventures in overthinking- making words from US state initials // Yozen Hernandez</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.111.3">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Yozen Hernandez" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.e04f32518dbcdbc64ddad5e1768be6d5edcc5cdba41caea400b8b4cdbc17a452.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Perl Weekly Challenge 14: van Eck’s sequence / Adventures in overthinking- making words from US state initials"/>
<meta name="twitter:description" content="Warning This post ended up being pretty long. A million thanks if you make it through to the end.
This week&rsquo;s Perl Weekly Challenge offered two very nice challenges that I really had to think about. Later in the week, Neil Bowers, who is credited with suggesting the second challenge, posted about an additional challenge since his submission was misunderstood.
Now with that out of the way, let me walk you through how I approached these challenges."/>

    <meta property="og:title" content="Perl Weekly Challenge 14: van Eck’s sequence / Adventures in overthinking- making words from US state initials" />
<meta property="og:description" content="Warning This post ended up being pretty long. A million thanks if you make it through to the end.
This week&rsquo;s Perl Weekly Challenge offered two very nice challenges that I really had to think about. Later in the week, Neil Bowers, who is credited with suggesting the second challenge, posted about an additional challenge since his submission was misunderstood.
Now with that out of the way, let me walk you through how I approached these challenges." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yzhernand.github.io/posts/perl-weekly-challenge-14/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-30T12:01:08-04:00" />
<meta property="article:modified_time" content="2019-06-30T12:01:08-04:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://yzhernand.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="Yozen Hernandez" /></a>
      <span class="app-header-title">Yozen Hernandez</span>
      <p>Bioinformatician who programs in Perl, C, and R. Occasionally writes about things.</p>
      <div class="app-header-social">
        
          <a href="https://github.com/yzhernand" target="_blank" rel="noreferrer noopener me">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
          <a href="https://fosstodon.org/@yzh" target="_blank" rel="noreferrer noopener me">
            <span class="icon">
  <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Mastodon</title><path d="M23.268 5.313c-.35-2.578-2.617-4.61-5.304-5.004C17.51.242 15.792 0 11.813 0h-.03c-3.98 0-4.835.242-5.288.309C3.882.692 1.496 2.518.917 5.127.64 6.412.61 7.837.661 9.143c.074 1.874.088 3.745.26 5.611.118 1.24.325 2.47.62 3.68.55 2.237 2.777 4.098 4.96 4.857 2.336.792 4.849.923 7.256.38.265-.061.527-.132.786-.213.585-.184 1.27-.39 1.774-.753a.057.057 0 0 0 .023-.043v-1.809a.052.052 0 0 0-.02-.041.053.053 0 0 0-.046-.01 20.282 20.282 0 0 1-4.709.545c-2.73 0-3.463-1.284-3.674-1.818a5.593 5.593 0 0 1-.319-1.433.053.053 0 0 1 .066-.054c1.517.363 3.072.546 4.632.546.376 0 .75 0 1.125-.01 1.57-.044 3.224-.124 4.768-.422.038-.008.077-.015.11-.024 2.435-.464 4.753-1.92 4.989-5.604.008-.145.03-1.52.03-1.67.002-.512.167-3.63-.024-5.545zm-3.748 9.195h-2.561V8.29c0-1.309-.55-1.976-1.67-1.976-1.23 0-1.846.79-1.846 2.35v3.403h-2.546V8.663c0-1.56-.617-2.35-1.848-2.35-1.112 0-1.668.668-1.67 1.977v6.218H4.822V8.102c0-1.31.337-2.35 1.011-3.12.696-.77 1.608-1.164 2.74-1.164 1.311 0 2.302.5 2.962 1.498l.638 1.06.638-1.06c.66-.999 1.65-1.498 2.96-1.498 1.13 0 2.043.395 2.74 1.164.675.77 1.012 1.81 1.012 3.12z"/></svg>
</span>
          </a>
        
          <a href="https://www.linkedin.com/in/yzhernand/" target="_blank" rel="noreferrer noopener me">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin">
  <title>LinkedIn</title>
  <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>
</svg>
          </a>
        
          <a href="https://www.researchgate.net/profile/Yoezen_Hernandez" target="_blank" rel="noreferrer noopener me">
            <span class="icon">
  <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>ResearchGate</title><path d="M19.586 0c-.818 0-1.508.19-2.073.565-.563.377-.97.936-1.213 1.68a3.193 3.193 0 0 0-.112.437 8.365 8.365 0 0 0-.078.53 9 9 0 0 0-.05.727c-.01.282-.013.621-.013 1.016a31.121 31.123 0 0 0 .014 1.017 9 9 0 0 0 .05.727 7.946 7.946 0 0 0 .077.53h-.005a3.334 3.334 0 0 0 .113.438c.245.743.65 1.303 1.214 1.68.565.376 1.256.564 2.075.564.8 0 1.536-.213 2.105-.603.57-.39.94-.916 1.175-1.65.076-.235.135-.558.177-.93a10.9 10.9 0 0 0 .043-1.207v-.82c0-.095-.047-.142-.14-.142h-3.064c-.094 0-.14.047-.14.141v.956c0 .094.046.14.14.14h1.666c.056 0 .084.03.084.086 0 .36 0 .62-.036.865-.038.244-.1.447-.147.606-.108.385-.348.664-.638.876-.29.212-.738.35-1.227.35-.545 0-.901-.15-1.21-.353-.306-.203-.517-.454-.67-.915a3.136 3.136 0 0 1-.147-.762 17.366 17.367 0 0 1-.034-.656c-.01-.26-.014-.572-.014-.939a26.401 26.403 0 0 1 .014-.938 15.821 15.822 0 0 1 .035-.656 3.19 3.19 0 0 1 .148-.76 1.89 1.89 0 0 1 .742-1.01c.344-.244.593-.352 1.137-.352.508 0 .815.096 1.144.303.33.207.528.492.764.925.047.094.111.118.198.07l1.044-.43c.075-.048.09-.115.042-.199a3.549 3.549 0 0 0-.466-.742 3 3 0 0 0-.679-.607 3.313 3.313 0 0 0-.903-.41A4.068 4.068 0 0 0 19.586 0zM8.217 5.836c-1.69 0-3.036.086-4.297.086-1.146 0-2.291 0-3.007-.029v.831l1.088.2c.744.144 1.174.488 1.174 2.264v11.288c0 1.777-.43 2.12-1.174 2.263l-1.088.2v.832c.773-.029 2.12-.086 3.465-.086 1.29 0 2.951.057 3.667.086v-.831l-1.49-.2c-.773-.115-1.174-.487-1.174-2.264v-4.784c.688.057 1.29.057 2.206.057 1.748 3.123 3.41 5.472 4.355 6.56.86 1.032 2.177 1.691 3.839 1.691.487 0 1.003-.086 1.318-.23v-.744c-1.031 0-2.063-.716-2.808-1.518-1.26-1.376-2.95-3.582-4.355-6.074 2.32-.545 4.04-2.722 4.04-4.9 0-3.208-2.492-4.698-5.758-4.698zm-.515 1.29c2.406 0 3.839 1.26 3.839 3.552 0 2.263-1.547 3.782-4.097 3.782-.974 0-1.404-.03-2.063-.086v-7.19c.66-.059 1.547-.059 2.32-.059z"/></svg>
</span>
          </a>
        
          <a href="https://orcid.org/0000-0003-3349-8856" target="_blank" rel="noreferrer noopener me">
            <span class="icon">
  <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>ORCID</title><path d="M12 0C5.372 0 0 5.372 0 12s5.372 12 12 12 12-5.372 12-12S18.628 0 12 0zM7.369 4.378c.525 0 .947.431.947.947s-.422.947-.947.947a.95.95 0 0 1-.947-.947c0-.525.422-.947.947-.947zm-.722 3.038h1.444v10.041H6.647V7.416zm3.562 0h3.9c3.712 0 5.344 2.653 5.344 5.025 0 2.578-2.016 5.025-5.325 5.025h-3.919V7.416zm1.444 1.303v7.444h2.297c3.272 0 4.022-2.484 4.022-3.722 0-2.016-1.284-3.722-4.097-3.722h-2.222z"/></svg>
</span>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Perl Weekly Challenge 14: van Eck’s sequence / Adventures in overthinking- making words from US state initials</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jun 30, 2019
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          13 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>Warning</strong> This post ended up being pretty long. A million thanks if you make it through to the end.</p>
<p>This week&rsquo;s <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-014/">Perl Weekly Challenge</a> offered two very nice challenges that I really had to think about. Later in the week, Neil Bowers, who is credited with suggesting the second challenge, <a href="http://neilb.org/2019/06/24/additional-challenge-14.html">posted</a> about an additional challenge since his submission was misunderstood.</p>
<p>Now with that out of the way, let me walk you through how I approached these challenges.</p>
<h1 id="challenge-1">Challenge 1</h1>
<blockquote>
<p>Write a script to generate Van Eck’s sequence starts with 0. For more information, please check out wikipedia <a href="https://en.wikipedia.org/wiki/Van_Eck%27s_sequence">page</a>. This challenge was proposed by team member Andrezgz.</p>
</blockquote>
<p>Another week, another numeric sequence :). van Eck&rsquo;s sequence is a bit trickier than other sequences I&rsquo;ve generated in previous challenges (see my posts on <a href="https://yzhernand.github.io/posts/perl-weekly-challenge-9/">challenge 9</a> where I simply generate squares, <a href="https://yzhernand.github.io/posts/perl-weekly-challenge-12/">challenge 12</a> which discusses <a href="https://en.wikipedia.org/wiki/Euclid_number">Euclid numbers</a>, and <a href="https://yzhernand.github.io/posts/perl-weekly-challenge-13/">challenge 13</a> which discusses <a href="https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter_Female_and_Male_sequences">Hofstadter Female and Male sequences</a>), as we will see.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-perl" data-lang="perl"><span style="display:flex;"><span><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">van_eck_seq</span> ( $n, $init = 0 ) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Base case. It should always be $init followed</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># by 0, given the definition.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ( $init, <span style="color:#ae81ff">0</span> ) <span style="color:#66d9ef">if</span> ( $n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">my</span> @seq <span style="color:#f92672">=</span> van_eck_seq( $n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, $init );
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">my</span> $m   <span style="color:#f92672">=</span> first { $seq[$_] <span style="color:#f92672">==</span> $seq[$n] } reverse( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> ( $n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) );
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">my</span> $val <span style="color:#f92672">=</span> ( defined $m ) ? ( $n <span style="color:#f92672">-</span> $m ) : <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> @seq, $val;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Going by the definition of the sequence on Wikipedia,</p>
<blockquote>
<p>\(a_0 = 0\). Then, for \(n ≥ 0\), if there exists an \(m &lt; n\) such that \(a_{m} = a_n\), take the largest such \(m\) and set \(a_{n+1} = n − m\); otherwise \(a_{n+1} = 0\).</p>
</blockquote>
<p>I thought of this as &ldquo;each \(n\)th term generates the \(n+1\)th term&rdquo;. So, if you call the function I&rsquo;ve written above with <code>van_eck_seq(2)</code> you would get the first 3 elements of the sequence, not the first 2. This is important because I&rsquo;ve written the function to be recursive, and the code following the nested call expects that the list it gets back includes the &ldquo;current&rdquo; \(n
\)th term.</p>
<p>Also by that definition, it looks like \(a_1 = 0\) since there is never an \(m &lt; n\) such that \(a_{m} = a_n\). The base case of <code>van_eck_seq(0)</code>, therefore, returns a list with items <code>(0, 0)</code>.</p>
<p>Actually, that&rsquo;s not totally true: van Eck&rsquo;s sequence can have a different \(a_0\) term, which changes the sequence. So my function definition allows an optional setting of that term as it&rsquo;s second argument, <code>$init</code>.</p>
<p>Continuing, for all \(n \geq 1\), we make a nested call to the same function, passing it <code>$n-1</code> and the value of <code>$init</code> (in case the caller changed it) and use the returned sequence to generate the next value.</p>
<p>This line:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-perl" data-lang="perl"><span style="display:flex;"><span><span style="color:#66d9ef">my</span> $m   <span style="color:#f92672">=</span> first { $seq[$_] <span style="color:#f92672">==</span> $seq[$n] } reverse( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> ( $n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) );
</span></span></code></pre></div><p>lets us walk backward through the sequence we got from the nested call so we can find that \(m &lt; n\) mentioned in the definition, if any. The value of <code>$val</code> depends on whether or not such an \(m\) was found, and then the combined sequence is returned. The function can be called like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-perl" data-lang="perl"><span style="display:flex;"><span>local $, <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;, &#34;</span>;
</span></span><span style="display:flex;"><span>say van_eck_seq(<span style="color:#ae81ff">10</span>);
</span></span></code></pre></div><p>which gives as output:</p>
<pre tabindex="0"><code>0, 0, 1, 0, 2, 0, 2, 2, 1, 6, 0, 5
</code></pre><p>For this challenge, I used the <code>Memoize</code> module instead of caching myself (see my <a href="https://yzhernand.github.io/posts/perl-weekly-challenge-13/">post</a> on last week&rsquo;s challenge). I also documented the behavior that the function call returns a list of n+1 elements, as a person who would want to use that function might not expect that.</p>
<p>See the full solution, <a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-014/yozen-hernandez/perl5/ch-1.pl">here</a>.</p>
<h1 id="challenge-2">Challenge 2</h1>
<blockquote>
<p>Using only the official postal (2-letter) abbreviations for the 50 U.S. states, write a script to find the longest English word you can spell? Here is the list of U.S. states abbreviations as per wikipedia page. This challenge was proposed by team member Neil Bowers.</p>
</blockquote>
<p>Turns out that this challenge wasn&rsquo;t quite what Neil intended, but I think most of us participants are going to solve it as-is. Further below I write about my solution to his actually intended challenge.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-perl" data-lang="perl"><span style="display:flex;"><span><span style="color:#66d9ef">my</span> %longest_word <span style="color:#f92672">=</span> ( words <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">[]</span>, length <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#...</span>
</span></span><span style="display:flex;"><span>open <span style="color:#66d9ef">my</span> $wl, <span style="color:#e6db74">&#34;&lt;&#34;</span>, <span style="color:#e6db74">&#34;/usr/share/dict/words&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> ( <span style="color:#66d9ef">my</span> $w <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;$wl&gt;</span> ) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Chomp and drop apostrophes or any other</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># non-alphabetical characters</span>
</span></span><span style="display:flex;"><span>    chomp $w;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">my</span> $w_alpha <span style="color:#f92672">=</span> $w;
</span></span><span style="display:flex;"><span>    $w_alpha <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/[^[:alpha:]]//g</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Skip unless length is even: all US state codes are bigrams</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">unless</span> ( length($w_alpha) % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Use unpack to split word into an array of bigrams</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># and use UC to make it all uppercase</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">my</span> @w_split <span style="color:#f92672">=</span> unpack <span style="color:#e6db74">&#34;(a2)*&#34;</span>, uc($w_alpha);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Skip if the set created from the word is not a</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># proper subset of the US state codes list.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">unless</span> all { exists $us_states_to_val{$_} } @w_split;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># By now, we can be sure that the word is only</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># composed of elements in the us_states list.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( length($w_alpha) <span style="color:#f92672">&gt;</span> $longest_word{length} ) {
</span></span><span style="display:flex;"><span>        @longest_word{<span style="color:#e6db74">qw(words length)</span>} <span style="color:#f92672">=</span> ( [$w], length($w) );
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elsif</span> ( length($w_alpha) <span style="color:#f92672">==</span> $longest_word{length} ) {
</span></span><span style="display:flex;"><span>        push $longest_word{words}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $w;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We start with a list of US states (not shown) and use a hash to store the length of the longest word seen and a list of those words, since there may be more than one. The length value is initialized to 0.</p>
<p>We skip all odd-length strings, because US state codes are all 2 letters long (bigrams). I tried using <code>unpack</code> for the first time ever because it looked like a nice way to generate a list of bigrams from a string. Then we reject any words which have a bigram which is not in the list of US state codes.</p>
<p>The final bit of code is just an if-elsif branch which checks if the word we found is longer than the longest seen so far. If it is, we basically reset the hash and store the word and new longest length. If it is the same, then we push the word onto the arrayref in the &ldquo;words&rdquo; value of the hash. Shorter words are just ignored.</p>
<p>I peeked at a few other solutions to this challenge after I was done. I think I like some of them better because they are more concise, but then I do like to break things up so that I can see what everything is doing a bit more easily. I suspect that performance is similar between the solutions, but I haven&rsquo;t done any benchmarking to check.</p>
<p>With the wordlist dictionary on Arch Linux, this script gives the following output:</p>
<pre tabindex="0"><code>Longest word(s) constructed using USPS state codes: armorial, calamari, calamine, coalmine, Concorde, Denmark&#39;s, Ganymede, landmine, mainland, malarial, Mandarin, mandarin, melamine, memorial, mescalin, moorland
with a length of 8 alphabetical characters
</code></pre><p>and using the alphabetic-only list from <a href="https://github.com/dwyl/english-words">https://github.com/dwyl/english-words</a></p>
<pre tabindex="0"><code>Longest word(s) constructed using USPS state codes: cacogalactia
with a length of 12 alphabetical characters
</code></pre><p>See the full solution, <a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-014/yozen-hernandez/perl5/ch-2.pl">here</a>.</p>
<h1 id="additional-challenge-2">Additional Challenge 2</h1>
<blockquote>
<p>What&rsquo;s the longest word you can spell by traversing US states, taking the initial or initials of the states as you pass through them, without revisiting any states?</p>
</blockquote>
<p>Ok so this one made me tear out my hair a little. I am a little jealous of others&rsquo; solutions which seemed much simpler than mine. But I am also a bit proud of the overengineering since I got to use some concepts in CS that I haven&rsquo;t really used since my undergrad.</p>
<p>When I first read the problem statement, I immediately thought of a <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">graph</a>. Basically, a graph is a data structure where things (usually strings, or another object of some sort) are connected to other things in some way. The &ldquo;things&rdquo; are called &ldquo;vertices&rdquo; (sing, vertex) and the connections are called &ldquo;edges&rdquo;. Graphs can have edges with, or without, direction, making traversal of the graphs different depending on the type of graph. Luckily there is a module, <a href="https://metacpan.org/pod/Graph"><code>Graph</code></a>, which is included in Perl which can represent these structures.</p>
<p>That takes care of the requirement that the states need to be adjacent. What about searching for words? In the previous challenge, we could just iterate over all words in the dictionary and check them to see if they could be made using the state codes. Here, we would actually need to generate words from the states, given their adjacency, and then check to see if that is a valid word.</p>
<p>Luckily, there is a data structure for that™: the <a href="https://en.wikipedia.org/wiki/Trie">Trie</a>, a search tree which allows for the lookup of words by prefix. It is ideal for applications such as predictive text, where words are suggested to a user based on the first few letters typed so far. We can use this to check if a word we are generating from the graph is in the dictionary. And of course, there is also a Perl module! <a href="https://metacpan.org/pod/Tree::Trie"><code>Tree::Trie</code></a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-perl" data-lang="perl"><span style="display:flex;"><span><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_paths</span> ( $graph, $trie, $vertex, $data, %seen ) {
</span></span><span style="display:flex;"><span>    $seen{$vertex} <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> ( keys %seen );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">my</span> $string_so_far <span style="color:#f92672">=</span> fc(
</span></span><span style="display:flex;"><span>        join( <span style="color:#e6db74">&#34;&#34;</span>,
</span></span><span style="display:flex;"><span>            map { $data<span style="color:#f92672">-&gt;</span>{$_}<span style="color:#f92672">-&gt;</span>{initials} }
</span></span><span style="display:flex;"><span>                ( sort { $seen{$a} <span style="color:#e6db74">&lt;=&gt;</span> $seen{$b} } keys %seen ) )
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Filter out successive vertexes which have already been visited</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># and which would not produce a word in the trie</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">my</span> @pot_successors <span style="color:#f92672">=</span> grep {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">!</span>( exists $seen{$_} )
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;&amp;</span> $trie<span style="color:#f92672">-&gt;</span>lookup(
</span></span><span style="display:flex;"><span>            $string_so_far <span style="color:#f92672">.</span> fc( $data<span style="color:#f92672">-&gt;</span>{$_}<span style="color:#f92672">-&gt;</span>{initials} ) );
</span></span><span style="display:flex;"><span>    } sort { $a <span style="color:#f92672">cmp</span> $b } $graph<span style="color:#f92672">-&gt;</span>neighbors($vertex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Base case: no more successors, done with this path</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>@pot_successors ) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ( join( <span style="color:#e6db74">&#34;-&gt;&#34;</span>, sort { $seen{$a} <span style="color:#e6db74">&lt;=&gt;</span> $seen{$b} } keys %seen ),
</span></span><span style="display:flex;"><span>            $string_so_far );
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Process successors</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>            map { get_paths( $graph, $trie, $_, $data, %seen ) }
</span></span><span style="display:flex;"><span>            @pot_successors;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I&rsquo;m not showing the code for initializing the graph or the trie here. You can check out the source code for that. The function above, however, lets us make several trips through the graph, given a starting point/vertex. We use a hash, <code>%seen</code> to keep track of the vertexes visited along the path so far. Each time a vertex is visited, it goes into the hash and gets a value based on the length of the path so far. I pay a penalty each time this function is called sorting that hash, but I&rsquo;m willing to do so.</p>
<p>The next chunk of code gives us a list of potential next vertices to visit, both by eliminating already visited vertices, and by checking if visiting that vertex we are still building a valid word. If taking that path would be a &ldquo;dead end&rdquo;, then we simply won&rsquo;t visit that vertex.</p>
<p>When there are no more potential successive nodes, we have reached the end of a path and build two strings: the path taken and the string generated. The former is just to make our output nicer and more informative. The latter is what we really want. These strings are returned as a two-element list which can be coerced into a hash by the first caller. Key collision should not be a problem since all the paths are different anyway.</p>
<p>If there are more nodes, we make a recursive call, starting at one of the potential vertices to visit next.</p>
<p><strong>Note:</strong> the fact that the <code>%seen</code> hash is not a hash ref makes this all relatively painless: each successive call to this function can make changes all it wants to the hash. Those changes will only live in that call&rsquo;s copy. So if we are iterating over other potential vertices way up in the first vertex, we can go deep down one path, and when we move on to another vertex, the next call to the function will get a copy of the <code>%seen</code> hash with only the first vertex in it. And so on for other successive calls.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-perl" data-lang="perl"><span style="display:flex;"><span><span style="color:#75715e"># Use a hash to save data on the longest word(s) found.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">my</span> %longest_word <span style="color:#f92672">=</span> ( paths <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">[]</span>, words <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">[]</span>, length <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">0</span> );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Iterate over all states in the graph.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $state ( sort $us_graph<span style="color:#f92672">-&gt;</span>vertices ) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Finds all paths with strings that may be in the dictionary and</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># save them into a hash.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">my</span> %paths <span style="color:#f92672">=</span> get_paths( $us_graph, $eng_words, $state, <span style="color:#f92672">\</span>%us_adj_data );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Set the trie to do exact string search only</span>
</span></span><span style="display:flex;"><span>    $eng_words<span style="color:#f92672">-&gt;</span>deepsearch(<span style="color:#e6db74">&#34;exact&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Iterate over all the path-&gt;word elements in the %paths hash</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ( <span style="color:#66d9ef">my</span> ( $path, $search ) <span style="color:#f92672">=</span> each %paths ) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Drop current path from the hash</span>
</span></span><span style="display:flex;"><span>        delete $paths{$path};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Do an exact string search for the word</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">my</span> $match <span style="color:#f92672">=</span> $eng_words<span style="color:#f92672">-&gt;</span>lookup($search);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( $match <span style="color:#f92672">&amp;&amp;</span> $match <span style="color:#f92672">eq</span> $search ) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># A word was found in the dictionary and its longer</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># than the longest seen so far. Clear the longest_word</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># hash and save the new data.</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ( length($search) <span style="color:#f92672">&gt;</span> $longest_word{length} ) {
</span></span><span style="display:flex;"><span>                @longest_word{<span style="color:#e6db74">qw(paths words length)</span>}
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">=</span> ( [$path], [$match], length($search) );
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elsif</span> ( length($search) <span style="color:#f92672">==</span> $longest_word{length} ) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># A word of the same length as the longest seen</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># was found. Push the data onto the list members</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># of the longest_word hash.</span>
</span></span><span style="display:flex;"><span>                push $longest_word{paths}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $path;
</span></span><span style="display:flex;"><span>                push $longest_word{words}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $match;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># last;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Change search setting again so we can do prefix searches on the</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># next iteration again.</span>
</span></span><span style="display:flex;"><span>    $eng_words<span style="color:#f92672">-&gt;</span>deepsearch(<span style="color:#e6db74">&#34;boolean&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Oh man this is a lot of stuff. The comments should help, however, and I will point out the important parts.</p>
<p>The code above iterates over all the states in the graph. For each state, we use the <code>get_paths</code> function to get all of the paths and generated words. The line</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-perl" data-lang="perl"><span style="display:flex;"><span>$eng_words<span style="color:#f92672">-&gt;</span>deepsearch(<span style="color:#e6db74">&#34;exact&#34;</span>);
</span></span></code></pre></div><p>sets searching the trie to look for exact matches only. It seems that this function doesn&rsquo;t really work as intended, but I need more time to test it and maybe report a bug. Anyway, this means that we can check to see if the word we generated is really a valid word, and not just a valid <em>prefix</em> of some word in the dictionary. If we did find an exact match, we save it in a similar way to the original challenge 2, except that now we also save the path.</p>
<p>Before moving on to the next state, we set the search back to &ldquo;boolean&rdquo;, which simply returns &ldquo;true&rdquo; if the prefix is in the trie.</p>
<p><strong>Note 2:</strong> In Challenge 2, I allowed words with apostrophes to be matched, but for some reason this resulted in some flaky output when using the trie. So for the additional challenge, I drop such words from the dictionary.</p>
<p>I am positive I over-thought and over-engineered this one, but it was fun to do it&hellip;once I got over the frustration of trying to use <a href="https://metacpan.org/pod/Graph::Traversal"><code>Graph::Traversal</code></a>. It didn&rsquo;t do what I wanted, and <code>get_paths</code> above was my solution. That ended up being better anyway as I had control over which paths not to take.</p>
<p>With the wordlist dictionary on Arch Linux, this script gives the following output:</p>
<pre tabindex="0"><code>Longest word(s) constructed using initials of US states: 
CO-&gt;OK-&gt;NM-&gt;AZ-&gt;NV = conman
with a length of 6 alphabetical characters
</code></pre><p>and using the alphabetic-only list from <a href="https://github.com/dwyl/english-words">https://github.com/dwyl/english-words</a></p>
<pre tabindex="0"><code>Longest word(s) constructed using initials of US states: 
CA-&gt;AZ-&gt;NV-&gt;UT-&gt;CO-&gt;KS = canuck
MO-&gt;AR-&gt;LA-&gt;MS-&gt;AL-&gt;GA = malmag
with a length of 6 alphabetical characters
</code></pre><p><strong>Cons:</strong> Besides being an overcomplicated solution, building the trie can take a while if it is very large. I am sure that a large enough graph would also be a problem.</p>
<p>See the full solution, <a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-014/yozen-hernandez/perl5/ch-2a.pl">here</a>.</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
